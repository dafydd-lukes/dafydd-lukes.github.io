{"pages":[{"tags":"pages","text":"I'm primarily a phonetician/linguist interested in programming and NLP applications, an avid fan of Linux and a beginning user of OS X. I like Python and Clojure and would like to learn me a Haskell for great good ; I find R useful (though convoluted on occasion) and avoid Perl as much as I can. I work at the Institute of the Czech National Corpus , so if you're interested in Czech and/or corpus linguistics , check us out! We have a nice and sleek web interface called KonText (with the manatee corpus query engine as a back-end) for all your Czech-related queries ;) I hail from Prague, Czech Republic, the most beautiful city in the world, and work and live there, though I've lived in France and Belgium for a while when I was a kid. I play badminton and football (of the soccer persuasion -- but it's still football) and enjoy American Jewish literature (to the point of writing my BA thesis on Philip Roth), as well as Jon Stewart, Ricky Gervais, Stephen Fry and several other smart people who can make me laugh. I used to play the saxophone reasonably well, but nowadays mostly enjoy playing the guitar atrociously bad and singing along. As you can tell from the title of this blog (if you're a fellow aficionado), I spent most of my teen years listening to the great music of one Frank Zappa . More about me on my homepage .","url":"http://dlukes.github.io/output/pages/about.html","title":"about me"},{"tags":"ling","text":"Or, the absolute minimum every software developer linguist absolutely, positively must know about Unicode and character sets (no excuses!) Note : This text was written as part of a larger programming tutorial in Python, and the code samples are taken from an interactive session using the Jupyter notebook . As a consequence, there are digressions here and there about playing with text data in Python. These might seem: useless if what you came for is just the part about text encoding; long-winded if you already know some Python; or confusing if, on the contrary, you're not familiar with programming at all, much less with Python. If any of these is your case, my advice is: ignore the code, focus on the comments around it, they're more than enough to follow the thread of the explanation. Though if you've got a little more time, why not try some of these out in an interactive Python session ? ;) And now, without further ado... Much like any other piece of data inside a digital computer, text is represented as a series of binary digits (bits), i.e. 0's and 1's. A mapping between sequences of bits and characters is called an encoding. How many different characters your encoding can handle depends on how many bits you allow per character: with 1 bit you can have 2&#94;1 = 2 characters (one is represented by 0, the other by 1) with 2 bits you can have 2&#94;2 = 4 characters(represented by 00, 01, 10 and 11) etc. The oldest encoding still in widespread use (it's what makes the Internet and the web tick) is ASCII , which is a 7-bit encoding: In [1]: 2 ** 7 Out[1]: 128 This means it can represent 128 different characters , which comfortably fits the basic Latin alphabet (both lowercase and uppercase), Arabic numerals, punctuation and some \"control characters\" which were primarily useful on the old teletype terminals for which ASCII was designed. For instance, the letter \"A\" corresponds to the number 65 ( 1000001 in binary, see below). \"ASCII\" stands for \" American Standard Code for Information Interchange\" -- which explains why there are no accented characters, for instance. Nowadays, ASCII is represented using 8 bits (== 1 byte), because that's the unit of computer memory which has become ubiquitous (in terms of both hardware and software assumptions), but still uses only 7 bits' worth of information. In [2]: 2 ** 8 Out[2]: 256 In [3]: # how to find out the binary representation of a decimal number? \"{:b}\" . format ( 65 ) Out[3]: &apos;1000001&apos; In [4]: # Digression/explanation: the format() method # # the format() string method inserts its arguments into the string # wherever there is a \"{}\" \"{} {} {}\" . format ( \"foo\" , \"bar\" , \"baz\" ) Out[4]: &apos;foo bar baz&apos; In [5]: # you can also specify a different order by using (zero-based) # positional indices -- or even repeating them \"{1} {0} {1}\" . format ( \"foo\" , \"bar\" ) Out[5]: &apos;bar foo bar&apos; In [6]: # for long strings with many insertions, where you might mess up the # order of arguments, keyword arguments are also available \"{foo_arg} {bar_arg}\" . format ( bar_arg = \"bar\" , foo_arg = \"foo\" ) Out[6]: &apos;foo bar&apos; In [7]: # and you can also request various formatting adjustments or conversions # to be made by specifying them after a \":\" -- e.g. \"b\" prints a given # number in its binary representation \"{:b}\" . format ( 45 ) Out[7]: &apos;101101&apos; In [8]: # or simply bin ( 45 ) # but that has an ugly \"0b\" in front, and we would've missed out on # format() if we'd used that directly! Out[8]: &apos;0b101101&apos; What happens in the range [128; 256) is not covered by the ASCII standard. In the 1990s, many encodings were standardized which used this range for their own purposes, usually representing additional accented characters used in a particular region. E.g. Czech (and Slovak, Polish...) alphabets can be represented using the ISO latin-2 encoding, or Microsoft's cp-1250 . Encodings which stick with the same character mappings as ASCII in the range [0; 128) and represent them physically in the same way (as 1 byte) , while potentially adding more character mappings beyond that, are called ASCII -compatible . ASCII compatibility is a good thing™, because when you start reading a character stream in a computer, there's no way to know in advance what encoding it is in (unless it's a file you've encoded yourself). So in practice, a heuristic has been established to start reading the stream assuming it is ASCII by default, and switch to a different encoding if evidence becomes available that motivates it. For instance, HTML files should all start something like this: <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" /> ... This way, whenever a program wants to read a file like this, it can start off with ASCII , waiting to see if it reaches the charset (i.e. encoding) attribute, and once it does, it can switch from ASCII to that encoding ( UTF-8 here) and restart reading the file, now fairly sure that it's using the correct encoding. This trick works only if we can assume that whatever encoding the rest of the file is in, the first few lines can be considered as ASCII for all practical intents and purposes. Without the charset attribute, the only way to know if the encoding is right would be for you to look at the rendered text and see if it makes sense; if it did not, you'd have to resort to trial and error, manually switching the encodings and looking for the one in which the numbers behind the characters stop coming out as gibberish and are actually translated into intelligible text. In [9]: # Let's take a look at printable characters in the latin-2 character # set. Each mapping is called a \"codepoint\": it is a correspondence # between an integer and a character. import codecs latin2 = [] for codepoint in range ( 256 ): byte = bytes ([ codepoint ]) character = codecs . decode ( byte , encoding = \"latin2\" ) if character . isprintable (): latin2 . append (( codepoint , character )) latin2 Out[9]: [(32, &apos; &apos;), (33, &apos;!&apos;), (34, &apos;\"&apos;), (35, &apos;#&apos;), (36, &apos;$&apos;), (37, &apos;%&apos;), (38, &apos;&&apos;), (39, \"&apos;\"), (40, &apos;(&apos;), (41, &apos;)&apos;), (42, &apos;*&apos;), (43, &apos;+&apos;), (44, &apos;,&apos;), (45, &apos;-&apos;), (46, &apos;.&apos;), (47, &apos;/&apos;), (48, &apos;0&apos;), (49, &apos;1&apos;), (50, &apos;2&apos;), (51, &apos;3&apos;), (52, &apos;4&apos;), (53, &apos;5&apos;), (54, &apos;6&apos;), (55, &apos;7&apos;), (56, &apos;8&apos;), (57, &apos;9&apos;), (58, &apos;:&apos;), (59, &apos;;&apos;), (60, &apos;<&apos;), (61, &apos;=&apos;), (62, &apos;>&apos;), (63, &apos;?&apos;), (64, &apos;@&apos;), (65, &apos;A&apos;), (66, &apos;B&apos;), (67, &apos;C&apos;), (68, &apos;D&apos;), (69, &apos;E&apos;), (70, &apos;F&apos;), (71, &apos;G&apos;), (72, &apos;H&apos;), (73, &apos;I&apos;), (74, &apos;J&apos;), (75, &apos;K&apos;), (76, &apos;L&apos;), (77, &apos;M&apos;), (78, &apos;N&apos;), (79, &apos;O&apos;), (80, &apos;P&apos;), (81, &apos;Q&apos;), (82, &apos;R&apos;), (83, &apos;S&apos;), (84, &apos;T&apos;), (85, &apos;U&apos;), (86, &apos;V&apos;), (87, &apos;W&apos;), (88, &apos;X&apos;), (89, &apos;Y&apos;), (90, &apos;Z&apos;), (91, &apos;[&apos;), (92, &apos;\\\\&apos;), (93, &apos;]&apos;), (94, &apos;&#94;&apos;), (95, &apos;_&apos;), (96, &apos;`&apos;), (97, &apos;a&apos;), (98, &apos;b&apos;), (99, &apos;c&apos;), (100, &apos;d&apos;), (101, &apos;e&apos;), (102, &apos;f&apos;), (103, &apos;g&apos;), (104, &apos;h&apos;), (105, &apos;i&apos;), (106, &apos;j&apos;), (107, &apos;k&apos;), (108, &apos;l&apos;), (109, &apos;m&apos;), (110, &apos;n&apos;), (111, &apos;o&apos;), (112, &apos;p&apos;), (113, &apos;q&apos;), (114, &apos;r&apos;), (115, &apos;s&apos;), (116, &apos;t&apos;), (117, &apos;u&apos;), (118, &apos;v&apos;), (119, &apos;w&apos;), (120, &apos;x&apos;), (121, &apos;y&apos;), (122, &apos;z&apos;), (123, &apos;{&apos;), (124, &apos;|&apos;), (125, &apos;}&apos;), (126, &apos;~&apos;), (161, &apos;Ą&apos;), (162, &apos;˘&apos;), (163, &apos;Ł&apos;), (164, &apos;¤&apos;), (165, &apos;Ľ&apos;), (166, &apos;Ś&apos;), (167, &apos;§&apos;), (168, &apos;¨&apos;), (169, &apos;Š&apos;), (170, &apos;Ş&apos;), (171, &apos;Ť&apos;), (172, &apos;Ź&apos;), (174, &apos;Ž&apos;), (175, &apos;Ż&apos;), (176, &apos;°&apos;), (177, &apos;ą&apos;), (178, &apos;˛&apos;), (179, &apos;ł&apos;), (180, &apos;´&apos;), (181, &apos;ľ&apos;), (182, &apos;ś&apos;), (183, &apos;ˇ&apos;), (184, &apos;¸&apos;), (185, &apos;š&apos;), (186, &apos;ş&apos;), (187, &apos;ť&apos;), (188, &apos;ź&apos;), (189, &apos;˝&apos;), (190, &apos;ž&apos;), (191, &apos;ż&apos;), (192, &apos;Ŕ&apos;), (193, &apos;Á&apos;), (194, &apos;Â&apos;), (195, &apos;Ă&apos;), (196, &apos;Ä&apos;), (197, &apos;Ĺ&apos;), (198, &apos;Ć&apos;), (199, &apos;Ç&apos;), (200, &apos;Č&apos;), (201, &apos;É&apos;), (202, &apos;Ę&apos;), (203, &apos;Ë&apos;), (204, &apos;Ě&apos;), (205, &apos;Í&apos;), (206, &apos;Î&apos;), (207, &apos;Ď&apos;), (208, &apos;Đ&apos;), (209, &apos;Ń&apos;), (210, &apos;Ň&apos;), (211, &apos;Ó&apos;), (212, &apos;Ô&apos;), (213, &apos;Ő&apos;), (214, &apos;Ö&apos;), (215, &apos;×&apos;), (216, &apos;Ř&apos;), (217, &apos;Ů&apos;), (218, &apos;Ú&apos;), (219, &apos;Ű&apos;), (220, &apos;Ü&apos;), (221, &apos;Ý&apos;), (222, &apos;Ţ&apos;), (223, &apos;ß&apos;), (224, &apos;ŕ&apos;), (225, &apos;á&apos;), (226, &apos;â&apos;), (227, &apos;ă&apos;), (228, &apos;ä&apos;), (229, &apos;ĺ&apos;), (230, &apos;ć&apos;), (231, &apos;ç&apos;), (232, &apos;č&apos;), (233, &apos;é&apos;), (234, &apos;ę&apos;), (235, &apos;ë&apos;), (236, &apos;ě&apos;), (237, &apos;í&apos;), (238, &apos;î&apos;), (239, &apos;ď&apos;), (240, &apos;đ&apos;), (241, &apos;ń&apos;), (242, &apos;ň&apos;), (243, &apos;ó&apos;), (244, &apos;ô&apos;), (245, &apos;ő&apos;), (246, &apos;ö&apos;), (247, &apos;÷&apos;), (248, &apos;ř&apos;), (249, &apos;ů&apos;), (250, &apos;ú&apos;), (251, &apos;ű&apos;), (252, &apos;ü&apos;), (253, &apos;ý&apos;), (254, &apos;ţ&apos;), (255, &apos;˙&apos;)] Using the 8th bit (and thus the codepoint range [128; 256)) solves the problem of handling languages with character sets different than that of American English, but introduces a lot of complexity -- whenever you come across a text file with an unknown encoding, it might be in one of literally dozens of encodings. Additional drawbacks include: how to handle multilingual text with characters from many different alphabets, which are not part of the same 8-bit encoding? how to handle writing systems which have way more than 256 \"characters\", e.g. Chinese, Japanese and Korean (CJK) ideograms? For these purposes, a standard encoding known as Unicode was developed which strives for universal coverage of all possible character sets. Unicode is much bigger than the encodings we've seen so far -- its most frequently used subset, the Basic Multilingual Plane , has 2&#94;16 codepoints, but overall the number of codepoints is past 1M and there's room to accommodate many more. In [10]: 2 ** 16 Out[10]: 65536 Now, the most straightforward representation for 2&#94;16 codepoints is what? Well, it's simply using 16 bits per character, i.e. 2 bytes. That encoding exists, it's called UTF-16 , but consider the drawbacks: we've lost ASCII compatibility by the simple fact of using 2 bytes per character instead of 1 (encoding \"a\" as 01100001 or 01100001|00000000 , with the | indicating an imaginary boundary between bytes, is not the same thing) encoding a string in a character set which uses a \"reasonable\" number of characters (like any European language) now takes twice as much space without any added benefit (which is probably not a good idea, given the general dominance of English -- one of those \"reasonable character set size\" languages -- in electronic communication) Looks like we'll have to think outside the box. The box in question here is called fixed-width encodings -- all of the encoding schemes we've encountered so far were fixed-width, meaning that each character was represented by either 7, 8 or 16 bits. In other word, you could jump around the string in multiples of 7, 8 or 16 and always land at the beginning of a character. (Not exactly true for UTF-16 , because it is something more than just a \"16-bit ASCII \": it has ways of handling characters beyond 2&#94;16 using so-called surrogate sequences -- but you get the gist.) \"UTF\" stands for \"Unicode Transformation Format\". The smart idea that some bright people have come up with was to use a variable-width encoding . The most ubiquitous one currently is UTF-8 , which we've already met in the HTML example above. UTF-8 is ASCII -compatible, i.e. the 1's and 0's used to encode text containing only ASCII characters are the same regardless of whether you use ASCII or UTF-8 : it's a sequence of 8-bit bytes. But UTF-8 can also handle many more additional characters, as defined by the Unicode standard, by using progressively longer and longer sequences of bits. In [11]: def print_as_binary_utf8 ( string ): \"\"\"Prints binary representation of string as encoded by UTF-8. \"\"\" # encode the string as UTF-8 byte = string . encode ( \"utf-8\" ) # get the hexadecimal representation of the bytes hexa = byte . hex () # convert the hexadecimal representation to a decimal integer inte = int ( hexa , base = 16 ) # create a string containing the integer, formatted as binary binary_str = \"'{}' encoded in UTF-8 is: {:b}\" . format ( string , inte ) # print that binary representation. whew! if there's an easier # way (e.g. at least skipping the intermediate hexadecimal # representation), please let me know! print ( binary_str ) print_as_binary_utf8 ( \"A\" ) # the representations... print_as_binary_utf8 ( \"č\" ) # ... keep... print_as_binary_utf8 ( \"字\" ) # ... getting longer. &apos;A&apos; encoded in UTF-8 is: 1000001 &apos;č&apos; encoded in UTF-8 is: 1100010010001101 &apos;字&apos; encoded in UTF-8 is: 111001011010110110010111 How does it achieve that? The obvious problem here is that with a fixed-width encoding, you just chop up the string at regular intervals (7, 8, 16 bits) and you know that each interval represents one character. So how do you know where to chop up a variable width-encoded string, if each character can take up a different number of bits? We won't go into the details, but essentially, the trick is to use some of the bits in the representation of a codepoint to store information not about which character it is (whether it's an \"A\" or a \"字\"), but how many bits it occupies . In other words, if you want to skip ahead 10 characters in a string encoded with a variable width-encoding, you can't just skip 10 * 7 or 8 or 16 bits; you have to read all the intervening characters to figure out how much space they take up. There's much more to Unicode than this simple introduction, for instance the various ways diacritics are handled: \"č\" can be represented either as a single codepoint ( LATIN SMALL LETTER C WITH CARON -- all Unicode codepoints have cute names like this) or a sequence of two codepoints, the character \"c\" and a combining diacritic mark ( COMBINING CARON ). You can search for the codepoints corresponding to Unicode characters e.g. here and play with them in Python using the chr(0xXXXX) built-in function or with the special string escape sequence \\uXXXX (where XXXX is the hexadecimal representation of the codepoint) -- both are ways to get the character corresponding to the given codepoint: In [12]: # \"č\" as LATIN SMALL LETTER C WITH CARON, codepoint 010D print ( chr ( 0x010D )) print ( \" \\u010D \" ) č č In [13]: # \"č\" as a sequence of LATIN SMALL LETTER C, codepoint 0063, and # COMBINING CARON, codepoint 030c print ( chr ( 0x0063 ) + chr ( 0x030c )) print ( \" \\u0063\\u030c \" ) č č Hexadecimal is just a more convenient way of representing sequences of bits, where each of the X 's can be a number between 0 and 15 (10--15 are represented by the letters A--F). Each hexadecimal number can thus represent 16 different values, and therefore it can stand in for a sequence of 4 bits (2&#94;4 == 16). Without worrying too much about the details right now, our old friend ASCII uppercase \"A\" can be thought of equivalently either as decimal 65, binary 1000001 , or hexadecimal 0x41 (the \"0x\" prefix is there just to say \"this is a hexadecimal number\"). > Binary and hexadecimal numbers are often written padded with leading zeros to some number of bytes, but these have no effect on the value, much like decimal 42 and 00000042 are effectively the same numbers. In [14]: # use hex() to find out the hexadecimal representation of a decimal # integer... hex ( 99 ) Out[14]: &apos;0x63&apos; In [15]: # ... and int() to go back int ( 0x63 ) Out[15]: 99 This means you have to be careful when working with languages that use accents, because for a computer, the two possible representations are of course different strings , even though for you, they're conceptually the same: In [16]: s1 = \" \\u010D \" s2 = \" \\u0063\\u030c \" # s1 and s2 look the same to the naked eye... print ( s1 , s2 ) č č In [17]: # ... but in the eternal realm of Plato's Ideas, they're not s1 == s2 Out[17]: False Watch out, they even have different lengths ! This might come to bite you if you're trying to compute the length of a word in letters. In [18]: print ( \"s1 is\" , len ( s1 ), \"character(s) long.\" ) print ( \"s2 is\" , len ( s2 ), \"character(s) long.\" ) s1 is 1 character(s) long. s2 is 2 character(s) long. Generally, most text out there will use the first, single-codepoint approach whenever possible, and pre-packaged linguistic corpora will try to be consistent about this (unless they come from the web, which always warrants being suspicious and defensive about your material). If you're worried about inconsistencies in your data, you can perform a normalization : In [19]: from unicodedata import normalize # NFC stands for Normal Form C; this normalization applies a canonical # decomposition (into a multi-codepoint representation) followed by a # canonical composition (into a single-codepoint representation) s1 = normalize ( \"NFC\" , s1 ) s2 = normalize ( \"NFC\" , s2 ) s1 == s2 Out[19]: True Let's wrap things up by saying that Python itself uses Unicode internally and (mostly?) assumes UTF-8 when reading files. So if you're using UTF-8 as is increasingly the case (and you should be), you won't have to worry too much about encodings, except perhaps for normalization. In [20]: # a good idea when dealing with Unicode text from an unknown and # unreliable source is to look at the set of codepoints contained # in it and eliminate or replace those that shouldn't be there import unicodedata def inspect_codepoints ( text ): charset = set () for char in text : charset . add ( char ) for char in sorted ( charset ): info = r\"{} (\\u{:04x}): {} (category: {})\" . format ( char , ord ( char ), unicodedata . name ( char ), unicodedata . category ( char )) print ( info ) # depending on your font configuration, it may be very hard to spot # the two intruders in the sentence below that look like regular # letters but really are specialized variants; you might want # to replace them before doing further text processing... inspect_codepoints ( \"Intruders here, good 𝗍hinɡ I checked.\" ) (\\u0020): SPACE (category: Zs) , (\\u002c): COMMA (category: Po) . (\\u002e): FULL STOP (category: Po) I (\\u0049): LATIN CAPITAL LETTER I (category: Lu) c (\\u0063): LATIN SMALL LETTER C (category: Ll) d (\\u0064): LATIN SMALL LETTER D (category: Ll) e (\\u0065): LATIN SMALL LETTER E (category: Ll) g (\\u0067): LATIN SMALL LETTER G (category: Ll) h (\\u0068): LATIN SMALL LETTER H (category: Ll) i (\\u0069): LATIN SMALL LETTER I (category: Ll) k (\\u006b): LATIN SMALL LETTER K (category: Ll) n (\\u006e): LATIN SMALL LETTER N (category: Ll) o (\\u006f): LATIN SMALL LETTER O (category: Ll) r (\\u0072): LATIN SMALL LETTER R (category: Ll) s (\\u0073): LATIN SMALL LETTER S (category: Ll) t (\\u0074): LATIN SMALL LETTER T (category: Ll) u (\\u0075): LATIN SMALL LETTER U (category: Ll) ɡ (\\u0261): LATIN SMALL LETTER SCRIPT G (category: Ll) 𝗍 (\\u1d5cd): MATHEMATICAL SANS-SERIF SMALL T (category: Ll) In [21]: # ... because of course, for a computer, the word \"thing\" written with # two different variants of \"g\" is really just two different words, which # is probably not what you want \"thing\" == \"thinɡ\" Out[21]: False In any case, here's what happens when processing text with Python (\"Unicode\" in the central box stands for Python's internal representation of Unicode, which is not UTF-8 nor UTF-16 ): (Image shamelessly hotlinked from / courtesy of the NLTK Book . Go check it out, it's an awesome intro to Python programming for linguists!) A terminological postscript: we've been using some terms a bit informally and for the most part it's okay, but it's good to get the distinctions straight in one's head at least once. So, a character set is a mapping between codepoints (integers) and characters . We may for instance say that in our character set, the integer 99 corresponds to the character \"c\". On the other hand, an encoding is a mapping between a codepoint (an integer) and a physical sequence of 1's and 0's that represent it in memory . With fixed-width encodings, this mapping is generally straightforward -- the 1's and 0's directly represent the given integer, only in binary and padded with zeros to fit the desired width. With variable-width encodings, as the necessity creeps in to include the information about how many bits are spanned by the current character, this straightforward correspondence breaks down. A comparison might be helpful here: as encodings, UTF-8 and UTF-16 both use the same character set -- the same integers corresponding to the same characters. But since they're different encodings , when the time comes to turn these integers into sequences of bits to store in a computer's memory, each of them generates a different one. For more on Unicode, a great read already hinted at above is Joel Spolsky's The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!) . To make the discussion digestible for newcomers, I sometimes slightly distorted facts about how things are \"really really\" done. And some inaccuracies may be genuine mistakes. In any case, please let me know in the comments! I'm grateful for feedback and looking to improve this material; I'll fix the mistakes and consider ditching some of the simplifications if they prove untenable :)","url":"http://dlukes.github.io/output/unicode.html","title":"How computers handle text: a gentle but thorough introduction to Unicode"},{"tags":"ling","text":"Před nějakou dobou jsem zde vyvěsil skript , jehož pomocí lze lehce \"přeskládat\" a upravit rozhraní korpusového konkordanceru KonText : menu je umístěné po straně místo nahoře a permanentně rozbalené nad vyhledanou konkordancí je umístěn rychlý hledací box, v němž lze předchozí dotaz pohodlně upravit Víc o motivaci těchto úprav se dočtete v původním článku . Stále platí, že ČNK nemá v plánu tyto změny začlenit přímo do oficiální verze KonTextu, zejména proto, že rychlý hledací box sice v jistých situacích může být užitečný, nicméně oproti standardnímu formuláři Nový dotaz výrazně omezuje možnosti pro zadání dotazu. Vylepšená verze, která je k dispozici níže, odstraňuje některé předchozí nedostatky skriptu: rychlý hledací box nad konkordancí je větší, ukazuje vždy CQL podobu posledního zadaného dotazu 1 , a především zůstává zobrazený i během listování konkordancí (tj. není k dispozici jen na její první stránce). Dotaz lze nyní navíc pro větší přehlednost rozdělit do více řádků, takže opětovné vyhledávání se nově spouští stiskem kombinace kláves Ctrl+Enter (místo jen Enteru). Výsledné upravené rozhraní KonText vypadá stále podobně: Postup instalace skriptu Nová verze skriptu je k dispozici zde: Kroky k jeho zprovoznění zůstávají stejné: Nainstalovat si do svého prohlížeče plugin Tampermonkey , pokud používáte Chrome, nebo Greasemonkey , pokud používáte Firefox. (Pokud používáte Internet Explorer, budete muset dočasně přesedlat na Chrome nebo Firefox.) Testovaný je skript zatím jen na Chromu. Založit v daném pluginu nový skript (pro Chrome je tutorial zde , pro Firefox zde ). Smazat kostru nového skriptu a nahradit ji skriptem, který si zkopírujete výše. Skript uložit. Používat KonText jako normálně -- skript už by podle adresy měl sám poznat, že se má spustit. Pokud se tak nestane, nejspíš to znamená, že je prohlížečový plugin (Tampermonkey nebo Greasemonkey) deaktivovaný a je potřeba jej znovu aktivovat. V předchozí verzi se po aplikaci libovolného filtru změnil obsah hledacího boxu na parametry filtrování. ↩","url":"http://dlukes.github.io/output/kontext-interface-tweak-update.html","title":"Úprava rozhraní konkordanceru KonText -- vylepšená verze"},{"tags":"ling","text":"!POZOR! K dispozici je nyní vylepšená verze níže popsaného skriptu . Hledání v korpusech ČNK Český národní korpus je sbírka jazykových korpusů částečně vytvářených Ústavem Českého národního korpusu a částečně jinými institucemi. Všechny jsou hostované na jednom serveru a dostupné skrz různá vyhledávací rozhraní (tzv. konkordancery ), např. NoSke , Bonito či nejnověji KonText . Koncem března 2015 ovšem bude podpora starších rozhraní ukončena a nadále půjde k datům v ČNK přistupovat primárně pouze přes KonText. (Pokud vám odstavec výše nedává příliš smysl, s jazykovými korpusy se setkáváte poprvé, ale chcete se dozvědět víc, raději si místo tohoto postu přečtěte, k čemu je takový korpus dobrý , a zkuste si v něm něco pro zajímavost vyhledat . Pokud se vám při vzpomínce na Bonito či NoSke naopak zaskvěla slza v oku, čtěte dál!) KonText vs. Bonito / NoSke KonText má oproti starším rozhraním řadu výhod -- bohatší funkcionalitu, mnohé pomůcky, které vám pomohou se zadáním složitějších dotazů (sestavení morfologického tagu či podmínky within ), a v neposlední řadě mnohem lépe vypadá, což kupříkladu mně při práci působí jako balzám na duši. Nicméně dlouholetí uživatelé ČNK byli jednoduše zvyklí na některé aspekty Bonita a NoSke, které jim teď v KonTextu chybí. Onehdy při rozhovoru s jedním z nich vyplavaly na povrch jako hodně důležité dvě stížnosti: Vrchní menu v KonTextu je zákeřné, schovává se, člověk nemá přehled nad dostupnými funkcemi. Oproti tomu NoSke má menu po straně a je permanentně rozvinuté, takže uživatel má všechny možnosti interakce s konkordancí soustavně jako na dlani. Po zadání dotazu člověk často na základě konkordance zjistí, že jej potřebuje ještě trochu upravit / zjemnit. KonText si sice předchozí dotazy pamatuje, je ale potřeba se k nim doklikat; šikovnější by bylo, kdyby tato možnost byla dostupná přímo ze stránky konkordance v podobě nějakého zjednodušeného hledacího boxu. (NoSke tohle vlastně taky neumí, v Bonitu je to jednodušší.) V obou případech jde o smysluplné požadavky, jenže KonText je poměrně velká a složitá aplikace, takže i pokud se ČNK rozhodne do ní tyto podněty v nějaké podobě zapracovat (např. jako možnost přepnutí zobrazení menu), bude nějakou chvíli trvat, než se implementace navrhne, vytvoří, řádně otestuje a konečně dostane k uživatelům. Nicméně aby bylo možné alespoň vyzkoušet, jak by zmíněné změny vypadaly v praxi, dal jsem dohromady krátký skript, který již v prohlížeči nahraný KonText trochu \"přestaví\" a upraví. Výsledek vypadá následovně: Rovnou předesílám: ten skript je nevzhledný bastl přilepený na KonText zvnějšku; proto taky bylo možné jej dát dohromady poměrně rychle, protože si neklade nárok na spolehlivost, která se vyžaduje od oficiální verze KonTextu. Je to spíš prototyp, jehož účelem je otestovat výše popsané změny v praxi a získat představu o tom, zda a do jaké míry jsou přínosné. (Vlastní zkušenost: po chvíli používání mi přijde přídatný hledací box nad konkordancí hodně šikovný a užitečný.) Teď k jádru pudla: pokud máte zájem, můžete si KonText takto k obrazu svému (resp. k obrázku o odstavec výš) upravit také a vyzkoušet, jak vám takové nastavení vyhovuje. Když se vám jedna z úprav bude líbit (nebo vás u toho napadne jiná, kterou by si KonText zasloužil), můžete pak zadat požadavek na nový feature . Návod, jak si KonText upravit, následuje níže. Postup instalace skriptu Skript samotný je k dispozici zde: K jeho zprovoznění jsou potřeba následující kroky: Nainstalovat si do svého prohlížeče plugin Tampermonkey , pokud používáte Chrome, nebo Greasemonkey , pokud používáte Firefox. (Pokud používáte Internet Explorer, budete muset dočasně přesedlat na Chrome nebo Firefox.) Testovaný je skript zatím jen na Chromu. Založit v daném pluginu nový skript (pro Chrome je tutorial zde , pro Firefox zde ). Smazat kostru nového skriptu a nahradit ji skriptem, který si zkopírujete výše. Skript uložit. Používat KonText jako normálně -- skript už by podle adresy měl sám poznat, že se má spustit. Pokud se tak nestane, nejspíš to znamená, že je prohlížečový plugin (Tampermonkey nebo Greasemonkey) deaktivovaný a je potřeba jej znovu aktivovat. Omezení Skript má pravděpodobně hromadu drobných much, na které se mi zatím nepodařilo přijít -- budu se je snažit průběžně opravovat, když na ně padnu, nebo když mi o nich dáte vědět . Krom toho má i některé mouchy, o nichž už vím, ale bohužel toho s nimi nejde moc dělat. Asi nejnápadnější je, že přidaný hledací box funguje jen na těch stránkách, kde je původní dotaz i součástí adresy URL (což nejsou všechny -- třeba když začnete listovat konkordancí na druhou stránku a dál, dotaz je z adresy vyjmut a pomocný hledací box tedy zmizí ). Ale vzhledem k tomu, že jeho hlavní účel má být možnost lehce upravit dotaz po prvním rychlém nahlédnutí do konkordance, snad to nebude takový problém. Pokud někdy bude podobný box řádně přidán přímo do KonTextu, takovými nedostatky samozřejmě trpět nebude. A ještě k používání přidaného hledacího boxu : Typ dotazu, který je do něj potřeba zadat, je stejný jako ten, který jste při prvotním vyhledání konkordance zadali na stránce Nový dotaz . Pokud tento prvotní dotaz byl Základní dotaz, můžete pomocí rychlého boxu zadat jiný Základní dotaz; pokud to byl CQL dotaz, můžete ho upravit zas jen na další CQL dotaz. Důvodem je, že smyslem tohoto pomocného boxu není nahradit plnohodnotný formulář pro zadání dotazu, jen poskytnout rychlou možnost, jak již zadaný dotaz upravit . Pomocný hledací box se objeví i poté, co na konkordanci provedete filtrování. V takové situaci se dá použít k tomu, abyste pozměnili zadání aktuálního filtru , tj. filtrování se provede znovu na původní konkordanci, ne na této již filtrované. Pokud chcete opakovaně filtrovat tu samou konkordanci a postupně podle daných kritérií vyřazovat / přidávat řádky, je potřeba místo hledacího boxu opakovaně použít menu Filtr . Komu si stěžovat, když to nebude fungovat Skript je volně šiřitelný pod licencí GNU GPL v3 , takže se na něj neváže žádná záruka. Když se vám ale nebude dařit jej zprovoznit, rád se pokusím pomoct! Stačí se ozvat na adresu uvedenou zde .","url":"http://dlukes.github.io/output/kontext-interface-tweak.html","title":"Úprava rozhraní konkordanceru KonText"},{"tags":"floss","text":"Background Ever since I first read about semantic versioning , I've thought of it as a neat idea. But only recently did it occur to me that what I liked about the idea was its goal, much less its execution (more on that below). What made it obvious was this lengthy discussion about breaking changes introduced in v1.7 of underscore.js without an accompanying major version bump. Even though I still think sticking to semver is the right thing to do if your community of users expects you to (even if you don't personally like the system), I am convinced there are fundamentally better ways of dealing with the problem of safely and consistently updating dependencies. It made me want to add my two cents to the discussion , as someone who's more of a dabbler in programming and not really part of the community, so feel free to ignore me :) I attach my commentary below for reference (it's virtually the same text as in the link above). tl;dr semver is trying to do the right thing, but doing it wrong -- instead of implicitly encoding severity of change information in version numbers , explicit keywords like :patch, :potentially-breaking or :major-api-change would make much more sense. More verbosely I've always found the goals of semver worthy, but this thread has made me realize that while its aims are commendable, its methods are kind of broken: semver tries to take an existing semiotic system (= version numbers), which has developed informally and is therefore a loose convention rather than an exact spec, and reinterpret it in terms of an exact spec (or impose that spec on it). trouble is, the prior informal meaning won't go away so easily (why should it?), especially for projects that have been around longer than semver. the problem then is, since the two systems (the informal one and semver) look the same in terms of their symbolic representation, it's hard to guess which one you're dealing with by just eyeballing the version number of a library (or project in general). it's like if someone decided that \"f*ck\" should mean \"orchid\" from now on, because it's nicer -- on hearing the word, you'd never know if it's being used as the original profanity, or in its new meaning. homonymy is a pain to deal with when it's accidental (cf. NLP), so why introduce it on purpose? the job that semver set out to do should be fulfilled by a new formal means which is instantly recognizable, not by hijacking an existing one and overlaying additional interpretation on it and thus making it ambiguous . even if version numbers hadn't existed before semver, they're terribly inadequate for the purpose of conveying information about the severity of changes introduced by an update (though I understand their appeal to mathematically-minded people). they're inadequate because they're implicit -- it's a bit like if someone decided they don't need hash maps because they can make do with arrays by remembering the order in which they're adding in the key-val pairs. if I remember the order, then I know which key the given index implicitly refers to, and the result is as good as a hash map, isn't it? except it isn't. keys are useful because they have explicit semantics , making it instantly clear what kind of value you're retrieving. in the same way, encoding the information about the severity of changes into version numbers makes it implicit (in addition to being ambiguous, as stated previously). why not use explicit keyword tags along with the version number (which can be romantic, semantic -- whichever floats the dev team's boat and best reflects the progress of the project) to give a heads up as to the nature of the update? e.g. :patch, :potentially-breaking, :major-api-change etc. granted, even language is a code which needs to be learned, like semver (gross oversimplification here, but let's not get into the details of language acquisition), but since it's widely established and conventionalized for conveying the kinds of meanings semver is trying to convey, why not just use it when it's available ? why use a system (version numbers) which is less well-suited to the purpose and ambiguous to boot? (on the other hand, numbers are eminently well-suited for keeping track of which version is newer than which and how much so -- the original purpose of version numbering -- because they are designed to have orderings defined on them. by contrast, words would do a terrible job at this. if you care to indicate the evolution of your codebase, you might introduce your own disciplined romantic or sentimental versioning scheme, which ironically is a more meaningful and ergo semantic way of doing versioning than semver, because it sticks to the conventional semantics of numbers (the closer the numbers, the more similar the versions). if you don't care about this, which is perfectly fine, you might as well use dates for version numbers.) keyword tags have the advantage that they're instantly human-readable by anyone who has a basic command of English. if there is sufficient will in the community, a useful subset can be frozen in a binding spec, so that they are machine-readable as well. I'm not sure whether these keywords should be an appendix to the version number (like v2.3.4-:potentially-breaking), or whether the information they provide should be more extensive and included in a formalized preamble to the changelog (finally forcing people to at least take a glance at it ;) ). using the latter approach, the information provided could be (optionally) even more targeted, e.g. detailing explicitly which parts of the API are affected in a non-backwards compatible manner by the update. anyways, just a few ideas :) I am not primarily a coder, so there may be obvious drawbacks to this scheme that I can't see or which have already been discussed by the community on multiple occasions which have escaped my attention. in which case, please bear with me and excuse my lack of sophistication.","url":"http://dlukes.github.io/output/beyond-semver.html","title":"Beyond semantic versioning? (cross-post)"},{"tags":"os x tips","text":"tl;dr Jump directly to the proposed solution . Tested on OS X 10.9 (Mavericks). Back story Airmail is a great application -- being very happy with Gmail's in-browser UI, it's honestly the first e-mail desktop client that I ever felt even remotely tempted to use. It has: a sleek, functional design almost flawless integration with Gmail (except for categories -- but there's a not-too-hackish way to deal with those) a Markdown compose mode (yay!) -- and tons of other good stuff. Especially that last feature almost got me sold -- you see, I like my e-mail hardwrapped (what Emacs calls \"filling paragraphs\"), because most of the time, I view it on monitors that are too wide for soft line wrapping to achieve a comfortable text width. (By the way, Airmail's layout deals with this issue very elegantly, but I know I won't be using only Airmail. Plus there are the obvious netiquette issues -- lines \"should be\" wrapped at 72 characters etc.) In Gmail, I therefore use plain-text compose, which is fine for the purposes described above, but frustrating whenever you want to apply formatting (obviously, you can't -- it's plain text). I tried using the usual replacements for formatting like stars & co., and I don't know about your grandma, but mine certainly doesn't take *...* to mean emphasis. I thought the Markdown compose mode in Airmail would solve my problems -- I could apply formatting if and when I wanted (using the frankly more streamlined process of typing it in rather than fumbling around for the right button in the GUI) and fill my paragraphs, because I somehow automatically assumed there'd by a hard-wrap feature like in any decent editor (read: emacs or vi). Markdown is plain text after all, isn't it? Long story short, as of yet, there isn't . There isn't even one for the plain-text compose mode, as far as I'm aware. So I added my two cents to this feature request thread and went back to the Gmail in-browser UI. Solution But then I realized (it took me a while, I'm still very much an OS X newbie): in OS X, you can define custom actions with shortcuts 1 for any application using Automator Services these actions can be easily set to receive text selected in the application as input these actions can also involve shell scripts there already is a great (command line) program for filling paragraphs -- it's called par , and as much as I admire what Airmail's developers have achieved, it's unlikely that they'd come up with a more sophisticated hard-wrapping algorithm than par 's simply as a side project for Airmail (see the EXAMPLES section in man par ) With that in mind, you can have hard-wrapping in Markdown or plain-text Airmail compose at your fingertips in no time flat. If you don't have homebrew , start by installing that (or any other ports manager that will allow you to install par ; I'll assume homebrew below) by pasting ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" at a Terminal prompt. Then: install par with brew install par at a Terminal prompt open Automator (e.g. by typing \"Automator\" into Spotlight) and create a new Service select the applications for which you want the service to be active (for me, that's just Airmail) and tick the \"Output replaces selected text\" box drag the \"Run Shell Script\" action onto the workflow canvas, and as the shell script, paste in PARINIT = \"rTbgqR B=.,?_A_a Q=_s>|\" /usr/local/bin/par 79 the $PARINIT environment variable contains the default recommended settings for par (if you want to customize its behavior, you can -- good luck wrapping your head around par 's manpage, though) you should set the full path to the par executable, the shell spawned by the Service might not inherit your $PATH -- for par installed via homebrew , it's /usr/local/bin/par the parameter at the end is the max number of characters per line -- mailing list etiquette stipulates 72, I personally prefer the pythonesque 79, but it's your choice At this point, your service should look something like in the screenshot below: Save it, open Keyboard preferences (type \"Keyboard\" into Spotlight), navigate to Shortcuts → Services → Text and set a keyboard shortcut for your newly created Service, e.g. Cmd+Opt+P. Next time you compose an e-mail in Airmail, just select the entire text when you're done (Cmd+A), press Cmd+Opt+P, and voilà! Your lines have been hardwrapped, your paragraphs filled :) (Same thing, I know.) If the shortcut doesn't appear to work 1 , try fiddling around with it, resetting it (maybe the one you've chosen conflicts with a pre-existing one?), restarting Airmail, logging out and back in, rebooting... The custom shortcut part is unfortunately the least reliable aspect of this whole setup. Automator is a great idea, I was pleasantly surprised by it when I started using OS X a few days back, but it could seriously use some bug-squashing. If you fail miserably at getting the shortcut to work, you can still access your fill paragraph service via the menu (select the text you want to hard-wrap, then navigate to Airmail → Services → <name of your fill paragraph service>). Clicking around in a GUI is tedious (though hey -- it's the Apple way after all, isn't it?), but it shouldn't be too much of a bother since you need to do it only once per e-mail. Bottom line : I am now officially completely sold on Airmail (even bought the released version instead of using the free beta) and look forward to the joy of using it! EDIT: In order to have the least trouble possible getting the shell script up and running as a Service , two rules of thumb: Leave it completely up to OS X where it stores the Service (.workflow) file. This will probably be in ~/Library/Services , and I learnt the hard way not to tinker with it -- if Services is a symlink instead of a real directory, the OS won't discover new Service files (though old ones will still be accessible). If the Service doesn't show up in the keyboard shortcuts menu after creation, try refreshing the service list with /System/Library/CoreServices/pbs -update . Those shortcuts are in fact quite buggy, especially those that you want to be global (not specific to a concrete app) -- at least on Mavericks (OS X 10.9). They tend to get disabled on a whim, especially if you tinker with them, and are a pain to get working again (login, logout, reboot -- anything goes). If anyone knows why, please let me know! ↩","url":"http://dlukes.github.io/output/fill-par-in-airmail.html","title":"Filling (hardwrapping) paragraphs in Airmail with `par`"},{"tags":"os x tips","text":"Coming soon!","url":"http://dlukes.github.io/output/configuring-emacs-daemon-on-mac-os-x.html","title":"Configuring Emacs Daemon on Mac OS X"}]}